1.自我介绍
2.项目介绍
3.特色功能
4.redux（介绍）在项目哪里用到
5.常用的布局方式
6.垂直水平居中
7.before伪类使用场景
8.如果有新需求，开发时间不够怎么办
9.接口有问题怎么沟通
11.常见hooks
12.为什么有hooks
13.promise失败后可以返回到成功吗
14.promise使用场景
15.怎么确保上一个promise执行完成后再执行下一个
16.事件循环
18.了解react源码吗  
19.平常通过那些渠道学习，学到了什么，针对学到的问题提问
19.给一个页面，设计增删改查，说一下思路
3.useefect模仿生命周期，
4.和componentdidupdate区别，怎么模仿
5.节流，防抖，立即执行防抖
6.数据类型，判断
7.闭包，for循环里面定时器输出
8.调用子组件方法
9剪头函数普通函数区别
10this指向
11.react16.8新特性  
12.递归一直执行问题，
13深拷贝
14.hooks的优势
15.函数和类组件的区别，
16改变this指向的方式，
17.还有memo父组件更新，子组件怎么优化
18.如果设计外边距50%或者padding50% 这个百分之五十是相对谁的
1.什么时候可以到岗 
2.实现异步--then返回什么 
3.同时发送多个请求，有一个成功就可以  
4.闭包  ---应用场景 
5.bfc  
6. 行内块 行内   
7.判断是否登录，
8.盒子模型
9.vue2.vue响应式原理区别
10.浏览器缓存
11.url之后干了什么
12.手写promise.all
13.计算数组深度
14.css布局 方式
15.介绍flex属性
16.垂直水平居中
17.重绘和重排
18.react逻辑复用
19.组件复用
20.组件通信
21.调用子组件方法







vite

webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。 而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。 由于现代浏览器本身就支持ES Module，会自动向依赖的Module发出请求。vite充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像webpack那样进行打包合并。 由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。 在HMR方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。 当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。




vue新特性
axios
setup
computed，watch
nextTick
获取dom元素
获取路由参数
路由router，route
导航守卫
响应式原理
vuex
call，apply，bind
Vue线上环境和开发环境如何切换
数组合并
http                                                                                                
http状态码
http和https区别
宏任务和微任务
promise
flex
css3动画，渐变，滤镜
水平垂直居中





自我介绍
学校课程
项目
mutation和action的区别

- action主要处理的是异步的操作，mutation必须同步执行，而action就不受这样的限制，也就是说action中我们既可以处理同步，也可以处理异步的操作
- action改变状态，最后是通过提交mutation



setup
严格模式
跨域
options
Vue组件通讯方式
computed和watch
防抖和节流
AJax ，axios和fetch的区别
http状态码
promise
闭包
原型链
JS的数据类型
判断JS的数据类型
作用域
vue2 vue3

